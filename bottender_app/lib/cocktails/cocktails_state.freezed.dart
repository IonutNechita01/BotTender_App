// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'cocktails_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CocktailsState {
  List<CocktailModel> get cocktails => throw _privateConstructorUsedError;
  List<CocktailModel> get filteredCocktails =>
      throw _privateConstructorUsedError;
  List<CocktailModel> get savedCocktails => throw _privateConstructorUsedError;
  List<bool Function(CocktailModel)> get filters =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<CocktailModel> cocktails,
            List<CocktailModel> filteredCocktails,
            List<CocktailModel> savedCocktails,
            List<bool Function(CocktailModel)> filters)
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            List<CocktailModel> cocktails,
            List<CocktailModel> filteredCocktails,
            List<CocktailModel> savedCocktails,
            List<bool Function(CocktailModel)> filters)?
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<CocktailModel> cocktails,
            List<CocktailModel> filteredCocktails,
            List<CocktailModel> savedCocktails,
            List<bool Function(CocktailModel)> filters)?
        initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialCocktailsState value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialCocktailsState value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialCocktailsState value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CocktailsStateCopyWith<CocktailsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CocktailsStateCopyWith<$Res> {
  factory $CocktailsStateCopyWith(
          CocktailsState value, $Res Function(CocktailsState) then) =
      _$CocktailsStateCopyWithImpl<$Res, CocktailsState>;
  @useResult
  $Res call(
      {List<CocktailModel> cocktails,
      List<CocktailModel> filteredCocktails,
      List<CocktailModel> savedCocktails,
      List<bool Function(CocktailModel)> filters});
}

/// @nodoc
class _$CocktailsStateCopyWithImpl<$Res, $Val extends CocktailsState>
    implements $CocktailsStateCopyWith<$Res> {
  _$CocktailsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cocktails = null,
    Object? filteredCocktails = null,
    Object? savedCocktails = null,
    Object? filters = null,
  }) {
    return _then(_value.copyWith(
      cocktails: null == cocktails
          ? _value.cocktails
          : cocktails // ignore: cast_nullable_to_non_nullable
              as List<CocktailModel>,
      filteredCocktails: null == filteredCocktails
          ? _value.filteredCocktails
          : filteredCocktails // ignore: cast_nullable_to_non_nullable
              as List<CocktailModel>,
      savedCocktails: null == savedCocktails
          ? _value.savedCocktails
          : savedCocktails // ignore: cast_nullable_to_non_nullable
              as List<CocktailModel>,
      filters: null == filters
          ? _value.filters
          : filters // ignore: cast_nullable_to_non_nullable
              as List<bool Function(CocktailModel)>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InitialCocktailsStateImplCopyWith<$Res>
    implements $CocktailsStateCopyWith<$Res> {
  factory _$$InitialCocktailsStateImplCopyWith(
          _$InitialCocktailsStateImpl value,
          $Res Function(_$InitialCocktailsStateImpl) then) =
      __$$InitialCocktailsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<CocktailModel> cocktails,
      List<CocktailModel> filteredCocktails,
      List<CocktailModel> savedCocktails,
      List<bool Function(CocktailModel)> filters});
}

/// @nodoc
class __$$InitialCocktailsStateImplCopyWithImpl<$Res>
    extends _$CocktailsStateCopyWithImpl<$Res, _$InitialCocktailsStateImpl>
    implements _$$InitialCocktailsStateImplCopyWith<$Res> {
  __$$InitialCocktailsStateImplCopyWithImpl(_$InitialCocktailsStateImpl _value,
      $Res Function(_$InitialCocktailsStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cocktails = null,
    Object? filteredCocktails = null,
    Object? savedCocktails = null,
    Object? filters = null,
  }) {
    return _then(_$InitialCocktailsStateImpl(
      cocktails: null == cocktails
          ? _value._cocktails
          : cocktails // ignore: cast_nullable_to_non_nullable
              as List<CocktailModel>,
      filteredCocktails: null == filteredCocktails
          ? _value._filteredCocktails
          : filteredCocktails // ignore: cast_nullable_to_non_nullable
              as List<CocktailModel>,
      savedCocktails: null == savedCocktails
          ? _value._savedCocktails
          : savedCocktails // ignore: cast_nullable_to_non_nullable
              as List<CocktailModel>,
      filters: null == filters
          ? _value._filters
          : filters // ignore: cast_nullable_to_non_nullable
              as List<bool Function(CocktailModel)>,
    ));
  }
}

/// @nodoc

class _$InitialCocktailsStateImpl extends _InitialCocktailsState {
  const _$InitialCocktailsStateImpl(
      {final List<CocktailModel> cocktails = const [],
      final List<CocktailModel> filteredCocktails = const [],
      final List<CocktailModel> savedCocktails = const [],
      final List<bool Function(CocktailModel)> filters = const []})
      : _cocktails = cocktails,
        _filteredCocktails = filteredCocktails,
        _savedCocktails = savedCocktails,
        _filters = filters,
        super._();

  final List<CocktailModel> _cocktails;
  @override
  @JsonKey()
  List<CocktailModel> get cocktails {
    if (_cocktails is EqualUnmodifiableListView) return _cocktails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_cocktails);
  }

  final List<CocktailModel> _filteredCocktails;
  @override
  @JsonKey()
  List<CocktailModel> get filteredCocktails {
    if (_filteredCocktails is EqualUnmodifiableListView)
      return _filteredCocktails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredCocktails);
  }

  final List<CocktailModel> _savedCocktails;
  @override
  @JsonKey()
  List<CocktailModel> get savedCocktails {
    if (_savedCocktails is EqualUnmodifiableListView) return _savedCocktails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_savedCocktails);
  }

  final List<bool Function(CocktailModel)> _filters;
  @override
  @JsonKey()
  List<bool Function(CocktailModel)> get filters {
    if (_filters is EqualUnmodifiableListView) return _filters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filters);
  }

  @override
  String toString() {
    return 'CocktailsState.initial(cocktails: $cocktails, filteredCocktails: $filteredCocktails, savedCocktails: $savedCocktails, filters: $filters)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialCocktailsStateImpl &&
            const DeepCollectionEquality()
                .equals(other._cocktails, _cocktails) &&
            const DeepCollectionEquality()
                .equals(other._filteredCocktails, _filteredCocktails) &&
            const DeepCollectionEquality()
                .equals(other._savedCocktails, _savedCocktails) &&
            const DeepCollectionEquality().equals(other._filters, _filters));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_cocktails),
      const DeepCollectionEquality().hash(_filteredCocktails),
      const DeepCollectionEquality().hash(_savedCocktails),
      const DeepCollectionEquality().hash(_filters));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialCocktailsStateImplCopyWith<_$InitialCocktailsStateImpl>
      get copyWith => __$$InitialCocktailsStateImplCopyWithImpl<
          _$InitialCocktailsStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<CocktailModel> cocktails,
            List<CocktailModel> filteredCocktails,
            List<CocktailModel> savedCocktails,
            List<bool Function(CocktailModel)> filters)
        initial,
  }) {
    return initial(cocktails, filteredCocktails, savedCocktails, filters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            List<CocktailModel> cocktails,
            List<CocktailModel> filteredCocktails,
            List<CocktailModel> savedCocktails,
            List<bool Function(CocktailModel)> filters)?
        initial,
  }) {
    return initial?.call(cocktails, filteredCocktails, savedCocktails, filters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<CocktailModel> cocktails,
            List<CocktailModel> filteredCocktails,
            List<CocktailModel> savedCocktails,
            List<bool Function(CocktailModel)> filters)?
        initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(cocktails, filteredCocktails, savedCocktails, filters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialCocktailsState value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialCocktailsState value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialCocktailsState value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialCocktailsState extends CocktailsState {
  const factory _InitialCocktailsState(
          {final List<CocktailModel> cocktails,
          final List<CocktailModel> filteredCocktails,
          final List<CocktailModel> savedCocktails,
          final List<bool Function(CocktailModel)> filters}) =
      _$InitialCocktailsStateImpl;
  const _InitialCocktailsState._() : super._();

  @override
  List<CocktailModel> get cocktails;
  @override
  List<CocktailModel> get filteredCocktails;
  @override
  List<CocktailModel> get savedCocktails;
  @override
  List<bool Function(CocktailModel)> get filters;
  @override
  @JsonKey(ignore: true)
  _$$InitialCocktailsStateImplCopyWith<_$InitialCocktailsStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}
